-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/GammaCorrectionHDLExample/Pixel_Str_ip_src_Gamma_Corrector.vhd
-- Created: 2017-11-05 13:15:12
-- 
-- Generated by MATLAB 9.2 and HDL Coder 3.10
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Pixel_Str_ip_src_Gamma_Corrector
-- Source Path: GammaCorrectionHDLExample/Pixel-Stream Gamma Compensation/Gamma Corrector
-- Hierarchy Level: 1
-- 
-- Gamma Corrector
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Pixel_Str_ip_src_Pixel_Stream_Gamma_Compensation_pkg.ALL;

ENTITY Pixel_Str_ip_src_Gamma_Corrector IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        in0                               :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        in1_hStart                        :   IN    std_logic;
        in1_hEnd                          :   IN    std_logic;
        in1_vStart                        :   IN    std_logic;
        in1_vEnd                          :   IN    std_logic;
        in1_valid                         :   IN    std_logic;
        out0                              :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        out1_hStart                       :   OUT   std_logic;
        out1_hEnd                         :   OUT   std_logic;
        out1_vStart                       :   OUT   std_logic;
        out1_vEnd                         :   OUT   std_logic;
        out1_valid                        :   OUT   std_logic
        );
END Pixel_Str_ip_src_Gamma_Corrector;


ARCHITECTURE rtl OF Pixel_Str_ip_src_Gamma_Corrector IS

  -- Constants
  CONSTANT Lookup_Table_table_data        : vector_of_unsigned8(0 TO 255) := 
    (to_unsigned(16#00#, 8), to_unsigned(16#15#, 8), to_unsigned(16#1C#, 8), to_unsigned(16#22#, 8),
     to_unsigned(16#27#, 8), to_unsigned(16#2B#, 8), to_unsigned(16#2E#, 8), to_unsigned(16#32#, 8),
     to_unsigned(16#35#, 8), to_unsigned(16#38#, 8), to_unsigned(16#3B#, 8), to_unsigned(16#3D#, 8),
     to_unsigned(16#40#, 8), to_unsigned(16#42#, 8), to_unsigned(16#44#, 8), to_unsigned(16#46#, 8),
     to_unsigned(16#48#, 8), to_unsigned(16#4A#, 8), to_unsigned(16#4C#, 8), to_unsigned(16#4E#, 8),
     to_unsigned(16#50#, 8), to_unsigned(16#52#, 8), to_unsigned(16#54#, 8), to_unsigned(16#55#, 8),
     to_unsigned(16#57#, 8), to_unsigned(16#59#, 8), to_unsigned(16#5A#, 8), to_unsigned(16#5C#, 8),
     to_unsigned(16#5D#, 8), to_unsigned(16#5F#, 8), to_unsigned(16#60#, 8), to_unsigned(16#62#, 8),
     to_unsigned(16#63#, 8), to_unsigned(16#65#, 8), to_unsigned(16#66#, 8), to_unsigned(16#67#, 8),
     to_unsigned(16#69#, 8), to_unsigned(16#6A#, 8), to_unsigned(16#6B#, 8), to_unsigned(16#6D#, 8),
     to_unsigned(16#6E#, 8), to_unsigned(16#6F#, 8), to_unsigned(16#70#, 8), to_unsigned(16#72#, 8),
     to_unsigned(16#73#, 8), to_unsigned(16#74#, 8), to_unsigned(16#75#, 8), to_unsigned(16#76#, 8),
     to_unsigned(16#77#, 8), to_unsigned(16#78#, 8), to_unsigned(16#7A#, 8), to_unsigned(16#7B#, 8),
     to_unsigned(16#7C#, 8), to_unsigned(16#7D#, 8), to_unsigned(16#7E#, 8), to_unsigned(16#7F#, 8),
     to_unsigned(16#80#, 8), to_unsigned(16#81#, 8), to_unsigned(16#82#, 8), to_unsigned(16#83#, 8),
     to_unsigned(16#84#, 8), to_unsigned(16#85#, 8), to_unsigned(16#86#, 8), to_unsigned(16#87#, 8),
     to_unsigned(16#88#, 8), to_unsigned(16#89#, 8), to_unsigned(16#8A#, 8), to_unsigned(16#8B#, 8),
     to_unsigned(16#8C#, 8), to_unsigned(16#8D#, 8), to_unsigned(16#8E#, 8), to_unsigned(16#8F#, 8),
     to_unsigned(16#90#, 8), to_unsigned(16#90#, 8), to_unsigned(16#91#, 8), to_unsigned(16#92#, 8),
     to_unsigned(16#93#, 8), to_unsigned(16#94#, 8), to_unsigned(16#95#, 8), to_unsigned(16#96#, 8),
     to_unsigned(16#97#, 8), to_unsigned(16#97#, 8), to_unsigned(16#98#, 8), to_unsigned(16#99#, 8),
     to_unsigned(16#9A#, 8), to_unsigned(16#9B#, 8), to_unsigned(16#9C#, 8), to_unsigned(16#9C#, 8),
     to_unsigned(16#9D#, 8), to_unsigned(16#9E#, 8), to_unsigned(16#9F#, 8), to_unsigned(16#A0#, 8),
     to_unsigned(16#A0#, 8), to_unsigned(16#A1#, 8), to_unsigned(16#A2#, 8), to_unsigned(16#A3#, 8),
     to_unsigned(16#A4#, 8), to_unsigned(16#A4#, 8), to_unsigned(16#A5#, 8), to_unsigned(16#A6#, 8),
     to_unsigned(16#A7#, 8), to_unsigned(16#A7#, 8), to_unsigned(16#A8#, 8), to_unsigned(16#A9#, 8),
     to_unsigned(16#AA#, 8), to_unsigned(16#AA#, 8), to_unsigned(16#AB#, 8), to_unsigned(16#AC#, 8),
     to_unsigned(16#AD#, 8), to_unsigned(16#AD#, 8), to_unsigned(16#AE#, 8), to_unsigned(16#AF#, 8),
     to_unsigned(16#AF#, 8), to_unsigned(16#B0#, 8), to_unsigned(16#B1#, 8), to_unsigned(16#B2#, 8),
     to_unsigned(16#B2#, 8), to_unsigned(16#B3#, 8), to_unsigned(16#B4#, 8), to_unsigned(16#B4#, 8),
     to_unsigned(16#B5#, 8), to_unsigned(16#B6#, 8), to_unsigned(16#B6#, 8), to_unsigned(16#B7#, 8),
     to_unsigned(16#B8#, 8), to_unsigned(16#B8#, 8), to_unsigned(16#B9#, 8), to_unsigned(16#BA#, 8),
     to_unsigned(16#BA#, 8), to_unsigned(16#BB#, 8), to_unsigned(16#BC#, 8), to_unsigned(16#BC#, 8),
     to_unsigned(16#BD#, 8), to_unsigned(16#BE#, 8), to_unsigned(16#BE#, 8), to_unsigned(16#BF#, 8),
     to_unsigned(16#C0#, 8), to_unsigned(16#C0#, 8), to_unsigned(16#C1#, 8), to_unsigned(16#C2#, 8),
     to_unsigned(16#C2#, 8), to_unsigned(16#C3#, 8), to_unsigned(16#C3#, 8), to_unsigned(16#C4#, 8),
     to_unsigned(16#C5#, 8), to_unsigned(16#C5#, 8), to_unsigned(16#C6#, 8), to_unsigned(16#C7#, 8),
     to_unsigned(16#C7#, 8), to_unsigned(16#C8#, 8), to_unsigned(16#C8#, 8), to_unsigned(16#C9#, 8),
     to_unsigned(16#CA#, 8), to_unsigned(16#CA#, 8), to_unsigned(16#CB#, 8), to_unsigned(16#CB#, 8),
     to_unsigned(16#CC#, 8), to_unsigned(16#CD#, 8), to_unsigned(16#CD#, 8), to_unsigned(16#CE#, 8),
     to_unsigned(16#CE#, 8), to_unsigned(16#CF#, 8), to_unsigned(16#CF#, 8), to_unsigned(16#D0#, 8),
     to_unsigned(16#D1#, 8), to_unsigned(16#D1#, 8), to_unsigned(16#D2#, 8), to_unsigned(16#D2#, 8),
     to_unsigned(16#D3#, 8), to_unsigned(16#D4#, 8), to_unsigned(16#D4#, 8), to_unsigned(16#D5#, 8),
     to_unsigned(16#D5#, 8), to_unsigned(16#D6#, 8), to_unsigned(16#D6#, 8), to_unsigned(16#D7#, 8),
     to_unsigned(16#D7#, 8), to_unsigned(16#D8#, 8), to_unsigned(16#D9#, 8), to_unsigned(16#D9#, 8),
     to_unsigned(16#DA#, 8), to_unsigned(16#DA#, 8), to_unsigned(16#DB#, 8), to_unsigned(16#DB#, 8),
     to_unsigned(16#DC#, 8), to_unsigned(16#DC#, 8), to_unsigned(16#DD#, 8), to_unsigned(16#DD#, 8),
     to_unsigned(16#DE#, 8), to_unsigned(16#DF#, 8), to_unsigned(16#DF#, 8), to_unsigned(16#E0#, 8),
     to_unsigned(16#E0#, 8), to_unsigned(16#E1#, 8), to_unsigned(16#E1#, 8), to_unsigned(16#E2#, 8),
     to_unsigned(16#E2#, 8), to_unsigned(16#E3#, 8), to_unsigned(16#E3#, 8), to_unsigned(16#E4#, 8),
     to_unsigned(16#E4#, 8), to_unsigned(16#E5#, 8), to_unsigned(16#E5#, 8), to_unsigned(16#E6#, 8),
     to_unsigned(16#E6#, 8), to_unsigned(16#E7#, 8), to_unsigned(16#E7#, 8), to_unsigned(16#E8#, 8),
     to_unsigned(16#E8#, 8), to_unsigned(16#E9#, 8), to_unsigned(16#E9#, 8), to_unsigned(16#EA#, 8),
     to_unsigned(16#EA#, 8), to_unsigned(16#EB#, 8), to_unsigned(16#EB#, 8), to_unsigned(16#EC#, 8),
     to_unsigned(16#EC#, 8), to_unsigned(16#ED#, 8), to_unsigned(16#ED#, 8), to_unsigned(16#EE#, 8),
     to_unsigned(16#EE#, 8), to_unsigned(16#EF#, 8), to_unsigned(16#EF#, 8), to_unsigned(16#F0#, 8),
     to_unsigned(16#F0#, 8), to_unsigned(16#F1#, 8), to_unsigned(16#F1#, 8), to_unsigned(16#F2#, 8),
     to_unsigned(16#F2#, 8), to_unsigned(16#F3#, 8), to_unsigned(16#F3#, 8), to_unsigned(16#F4#, 8),
     to_unsigned(16#F4#, 8), to_unsigned(16#F5#, 8), to_unsigned(16#F5#, 8), to_unsigned(16#F6#, 8),
     to_unsigned(16#F6#, 8), to_unsigned(16#F7#, 8), to_unsigned(16#F7#, 8), to_unsigned(16#F8#, 8),
     to_unsigned(16#F8#, 8), to_unsigned(16#F9#, 8), to_unsigned(16#F9#, 8), to_unsigned(16#F9#, 8),
     to_unsigned(16#FA#, 8), to_unsigned(16#FA#, 8), to_unsigned(16#FB#, 8), to_unsigned(16#FB#, 8),
     to_unsigned(16#FC#, 8), to_unsigned(16#FC#, 8), to_unsigned(16#FD#, 8), to_unsigned(16#FD#, 8),
     to_unsigned(16#FE#, 8), to_unsigned(16#FE#, 8), to_unsigned(16#FF#, 8), to_unsigned(16#FF#, 8));  -- ufix8 [256]

  -- Signals
  SIGNAL sregout                          : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL sregout_1                        : std_logic;  -- ufix1
  SIGNAL s                                : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL in0_unsigned                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL s_1                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL Lookup_Table_k                   : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL s_2                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL s_3                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL s_4                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL pixelOut                         : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL hStart_reg                       : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL hStartOut                        : std_logic;
  SIGNAL hEnd_reg                         : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL hEndOut                          : std_logic;
  SIGNAL vStart_reg                       : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL vStartOut                        : std_logic;
  SIGNAL vEnd_reg                         : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL vEndOut                          : std_logic;

BEGIN
  -- 2 clock delays for valid
  -- 
  -- dataOut maintains zero when validIn is low
  valid_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sregout <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sregout(0) <= sregout(1);
        sregout(1) <= in1_valid;
      END IF;
    END IF;
  END PROCESS valid_process;


  sregout_1 <= sregout(1);

  s <= to_unsigned(16#00#, 8);

  in0_unsigned <= unsigned(in0);

  -- convert dataIn to LUT address
  s_1 <= in0_unsigned;

  -- Gamma Curve Table
  
  Lookup_Table_k <= to_unsigned(16#00#, 8) WHEN s_1 = to_unsigned(16#00#, 8) ELSE
      to_unsigned(16#FF#, 8) WHEN s_1 = to_unsigned(16#FF#, 8) ELSE
      s_1;
  s_2 <= Lookup_Table_table_data(to_integer(Lookup_Table_k));

  -- To infer a RAM, the register following LUT is set to ResetNone
  LUTRegsiter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        s_3 <= s_2;
      END IF;
    END IF;
  END PROCESS LUTRegsiter_process;


  
  s_4 <= s WHEN sregout_1 = '0' ELSE
      s_3;

  reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      pixelOut <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        pixelOut <= s_4;
      END IF;
    END IF;
  END PROCESS reg_process;


  out0 <= std_logic_vector(pixelOut);

  -- 2 clock delays for hStart
  hStart_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hStart_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        hStart_reg(0) <= in1_hStart;
        hStart_reg(1) <= hStart_reg(0);
      END IF;
    END IF;
  END PROCESS hStart_process;

  hStartOut <= hStart_reg(1);

  out1_hStart <= hStartOut;

  -- 2 clock delays for hEnd
  hEnd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hEnd_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        hEnd_reg(0) <= in1_hEnd;
        hEnd_reg(1) <= hEnd_reg(0);
      END IF;
    END IF;
  END PROCESS hEnd_process;

  hEndOut <= hEnd_reg(1);

  out1_hEnd <= hEndOut;

  -- 2 clock delays for vStart
  vStart_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      vStart_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        vStart_reg(0) <= in1_vStart;
        vStart_reg(1) <= vStart_reg(0);
      END IF;
    END IF;
  END PROCESS vStart_process;

  vStartOut <= vStart_reg(1);

  out1_vStart <= vStartOut;

  -- 2 clock delays for vEnd
  vEnd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      vEnd_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        vEnd_reg(0) <= in1_vEnd;
        vEnd_reg(1) <= vEnd_reg(0);
      END IF;
    END IF;
  END PROCESS vEnd_process;

  vEndOut <= vEnd_reg(1);

  out1_vEnd <= vEndOut;

  out1_valid <= sregout(0);

END rtl;

